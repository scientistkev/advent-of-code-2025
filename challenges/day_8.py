# Since this is a teleporter lab, there are lots of spare parts, manuals, and diagnostic equipment lying around. After connecting one of the diagnostic tools, it helpfully displays error code 0H-N0, which apparently means that there's an issue with one of the tachyon manifolds.

# You quickly locate a diagram of the tachyon manifold (your puzzle input). A tachyon beam enters the manifold at the location marked S; tachyon beams always move downward. Tachyon beams pass freely through empty space (.). However, if a tachyon beam encounters a splitter (^), the beam is stopped; instead, a new tachyon beam continues from the immediate left and from the immediate right of the splitter.

# For example:

# .......S.......
# ...............
# .......^.......
# ...............
# ......^.^......
# ...............
# .....^.^.^.....
# ...............
# ....^.^...^....
# ...............
# ...^.^...^.^...
# ...............
# ..^...^.....^..
# ...............
# .^.^.^.^.^...^.
# ...............
# In this example, the incoming tachyon beam (|) extends downward from S until it reaches the first splitter:

# .......S.......
# .......|.......
# .......^.......
# ...............
# ......^.^......
# ...............
# .....^.^.^.....
# ...............
# ....^.^...^....
# ...............
# ...^.^...^.^...
# ...............
# ..^...^.....^..
# ...............
# .^.^.^.^.^...^.
# ...............
# At that point, the original beam stops, and two new beams are emitted from the splitter:

# .......S.......
# .......|.......
# ......|^|......
# ...............
# ......^.^......
# ...............
# .....^.^.^.....
# ...............
# ....^.^...^....
# ...............
# ...^.^...^.^...
# ...............
# ..^...^.....^..
# ...............
# .^.^.^.^.^...^.
# ...............
# Those beams continue downward until they reach more splitters:

# .......S.......
# .......|.......
# ......|^|......
# ......|.|......
# ......^.^......
# ...............
# .....^.^.^.....
# ...............
# ....^.^...^....
# ...............
# ...^.^...^.^...
# ...............
# ..^...^.....^..
# ...............
# .^.^.^.^.^...^.
# ...............
# At this point, the two splitters create a total of only three tachyon beams, since they are both dumping tachyons into the same place between them:

# .......S.......
# .......|.......
# ......|^|......
# ......|.|......
# .....|^|^|.....
# ...............
# .....^.^.^.....
# ...............
# ....^.^...^....
# ...............
# ...^.^...^.^...
# ...............
# ..^...^.....^..
# ...............
# .^.^.^.^.^...^.
# ...............
# This process continues until all of the tachyon beams reach a splitter or exit the manifold:

# .......S.......
# .......|.......
# ......|^|......
# ......|.|......
# .....|^|^|.....
# .....|.|.|.....
# ....|^|^|^|....
# ....|.|.|.|....
# ...|^|^|||^|...
# ...|.|.|||.|...
# ..|^|^|||^|^|..
# ..|.|.|||.|.|..
# .|^|||^||.||^|.
# .|.|||.||.||.|.
# |^|^|^|^|^|||^|
# |.|.|.|.|.|||.|
# To repair the teleporter, you first need to understand the beam-splitting properties of the tachyon manifold. In this example, a tachyon beam is split a total of 21 times.

# Analyze your manifold diagram. How many times will the beam be split?

def parse_input(input):
    grid = []
    for line in input.strip().split("\n"):
        grid.append(list(line))
    return grid

def count_beam_splits(grid):
    rows = len(grid)
    cols = len(grid[0])
    
    # Find the starting position 'S'
    start_row = 0
    start_col = 0
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == 'S':
                start_row = i
                start_col = j
                break
    
    # Track active beams: each beam is (row, col)
    # Beams always move downward
    active_beams = set([(start_row, start_col)])
    beam_splits = 0
    
    # Simulate beam propagation
    # Continue until no more active beams
    while active_beams:
        # Group beams by row to process them row by row
        beams_by_row = {}
        for beam_row, beam_col in active_beams:
            if beam_row not in beams_by_row:
                beams_by_row[beam_row] = []
            beams_by_row[beam_row].append((beam_row, beam_col))
        
        # Process from top to bottom
        new_beams = set()
        processed_rows = set()
        
        for row in sorted(beams_by_row.keys()):
            if row >= rows:
                continue
                
            for beam_row, beam_col in beams_by_row[row]:
                # Check if we've already processed this position
                if (beam_row, beam_col) in processed_rows:
                    continue
                
                # Check what's at this position
                if grid[beam_row][beam_col] == '^':
                    # Beam hits splitter - count the split
                    beam_splits += 1
                    
                    # Create two new beams at left and right of splitter
                    left_col = beam_col - 1
                    right_col = beam_col + 1
                    
                    # New beams start at the same row as the splitter
                    if left_col >= 0:
                        new_beams.add((beam_row, left_col))
                    if right_col < cols:
                        new_beams.add((beam_row, right_col))
                elif grid[beam_row][beam_col] == '.' or grid[beam_row][beam_col] == 'S':
                    # Beam passes through, continue downward
                    if beam_row + 1 < rows:
                        new_beams.add((beam_row + 1, beam_col))
                
                processed_rows.add((beam_row, beam_col))
        
        # Move all new beams down one step (they're at the splitter row, need to move down)
        # Actually wait - re-reading: "a new tachyon beam continues from the immediate left and from the immediate right"
        # I think this means the beams are created at the left/right positions and immediately start moving down
        
        # Update active beams: new beams that will move down
        next_beams = set()
        for beam_row, beam_col in new_beams:
            # If this position is a splitter, we'll process it in the next iteration
            # Otherwise, move down
            if beam_row + 1 < rows and grid[beam_row][beam_col] != '^':
                next_beams.add((beam_row + 1, beam_col))
            elif grid[beam_row][beam_col] == '^':
                # Beam is at a splitter position, process it
                next_beams.add((beam_row, beam_col))
            # If beam would exit grid, don't add it
        
        active_beams = next_beams
    
    return beam_splits

def main():
    with open("data/day_8_input.txt") as f:
        input_data = f.read()
    grid = parse_input(input_data)
    result = count_beam_splits(grid)
    print(f"Number of beam splits: {result}")

if __name__ == "__main__":
    main()